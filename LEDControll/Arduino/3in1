#include "FastLED.h"


#define NUM_LEDS 32 
#define DATA_PIN 7
#define CLOCK_PIN 13
#define COLOR_ORDER BGR
#define LED_TYPE  WS2801

uint8_t max_bright = 128;                                      
uint8_t thisdelay = 20;

struct CRGB leds[NUM_LEDS];

CRGB clr1;
CRGB clr2;
uint8_t speed;
uint8_t loc1;
uint8_t loc2;
uint8_t ran1;
uint8_t ran2;

CRGBPalette16 currentPalette(CRGB::Black);
CRGBPalette16 targetPalette(PartyColors_p );
TBlendType currentBlending;


void setup()
{
  Serial.begin(9600);

  delay(3000); //safety startup delay to protect LEDS
  FastLED.addLeds<LED_TYPE, DATA_PIN,CLOCK_PIN, COLOR_ORDER>(leds, NUM_LEDS);

} 

//Mood

void mood(){
  static uint8_t hue = 170; // start at blue
  FastLED.showColor(CHSV(hue++, 255, 191)); // loop trough all the hue colors
  //FastLED.delay(300); // FastLED2.1 has a bug
    delay(300);
}

void rainbow(){
    currentBlending = LINEARBLEND;  
  
  FastLED.setBrightness(max_bright);
  set_max_power_in_volts_and_milliamps(5, 500);               // FastLED Power management set at 5V, 500mA.
  ChangePalettePeriodically();
 EVERY_N_MILLISECONDS(100) {
    uint8_t maxChanges = 24; 
    nblendPaletteTowardPalette(currentPalette, targetPalette, maxChanges);
  }

 EVERY_N_MILLISECONDS(thisdelay) {
  static uint8_t startIndex = 0;
  startIndex += 1;                                 // motion speed
  FillLEDsFromPaletteColors(startIndex);
 }

  FastLED.show();
 
}

void FillLEDsFromPaletteColors(uint8_t colorIndex) {
  
  for(int i = 0; i < NUM_LEDS; i++) {
    leds[i] = ColorFromPalette(currentPalette, colorIndex + sin8(i*16), 255);
    colorIndex += 3;
  }

} 

void ChangePalettePeriodically() {
  
  uint8_t secondHand = (millis() / 1000) % 60;
  static uint8_t lastSecond = 99;
  
  if(lastSecond != secondHand) {
    lastSecond = secondHand;
    CRGB p = CHSV(HUE_PURPLE, 255, 255);
    CRGB g = CHSV(HUE_GREEN, 255, 255);
    CRGB b = CRGB::Black;
    CRGB w = CRGB::White;
    if(secondHand ==  0)  { targetPalette = RainbowColors_p; }
    if(secondHand == 10)  { targetPalette = CRGBPalette16(g,g,b,b, p,p,b,b, g,g,b,b, p,p,b,b); }
    if(secondHand == 20)  { targetPalette = CRGBPalette16(b,b,b,w, b,b,b,w, b,b,b,w, b,b,b,w); }
    if(secondHand == 30)  { targetPalette = LavaColors_p; }
    if(secondHand == 40)  { targetPalette = CloudColors_p; }
    if(secondHand == 50)  { targetPalette = PartyColors_p; }
  }
  
}

void blendwave() {

  speed = beatsin8(6,0,255);

  clr1 = blend(CHSV(beatsin8(3,0,255),255,255), CHSV(beatsin8(4,0,255),255,255), speed);
  clr2 = blend(CHSV(beatsin8(4,0,255),255,255), CHSV(beatsin8(3,0,255),255,255), speed);

  loc1 = beatsin8(10,0,NUM_LEDS-1);
  
  fill_gradient_RGB(leds, 0, clr2, loc1, clr1);
  fill_gradient_RGB(leds, loc1, clr2, NUM_LEDS-1, clr1);
  FastLED.show();

}

void loop()
{
  //mood();
  //rainbow();
  blendwave();
  

}